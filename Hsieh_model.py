# -*- coding: utf-8 -*-
"""
Created on Tue Mar  3 10:18:22 2020

@author: Marcos J Ribeiro
"""
# see this: https://pastebin.com/cvYBvW3B
# The model can be viewed in:  https://drive.google.com/drive/u/0/folders/1MOOHg2woM6B2MCLohTPk-kbIgO5RLbVZ


import numpy as np
import matplotlib.pyplot as plt
import math as mt
from scipy.optimize import minimize
from math import gamma
import itertools as itl
import time





#----------------------- Defining parameters



def par():
    global beta, eta, varphi, theta, rho, i, r, gamma1, phi
    beta = 0.69
    eta = 0.25
    varphi = 0.25
    theta = 3.44
    rho = 0.19
    i = 7
    r = 27
    gamma1 = gamma(1 - (theta*(1 - rho)**(-1)) * (1 - eta)**(-1))
    phi = [0.138, 0.174, 0.136, 0.1, 0.051, 0.084, 0.168]





#------------------------ h_til



def h_tilf( ):
    global h_til
    
    sf( )

    h_til = np.zeros((i, r))
    for c in range(i):
        for j in range(r):    
            h_til[c, j] = ( 1 ** varphi * s[c]**phi[c] * eta**eta )**(1 - eta)**(-1) 

    return h_til





#------------------------ Agregate Human capital   (eq 21)

 

def Hf( ):
    global H, E, c1
    h_tilf( )
    
    a = 1/ theta* ( 1 - rho )
    b = 1/ ( 1 - eta )
    
    g = gamma(1 - a * b)
              
    
    H = np.zeros((i, r))
    c1 = np.zeros(i)
    E = np.zeros(i)
    
    for c in range(i):               
            
        c1[c] = ( 1/p_i[c] )**(b / eta)
        E[c] = c1[c] * g
            
        for j in range(r): 
            
            H[c, j] = p_ir[c, j]*h_til[c, j] * ( ( (1 - tau_w[c, j])/(1 + tau_h[c, j]) ) * w[c, j] ) ** (eta/(1 - eta)) * E[c]
          
    return H



#for t in range(10):
#    Hf()
#    taus()
#    print(H.sum())
#    
#
#taus()
#Hf()
#

#----------------------------------------- s - time spent at school   (eq 14)



def sf( ):
    global s
    s = np.zeros((i, 1))
    
    for c in range(i):
        s[c] = (1+ (1-eta)/beta*phi[c])**(-1)                        
    return s




#----------------------------------------- w tilde

def H_trf():
    global H_tr
    H_tr = np.ones((i, r))
    return H_tr


def w_tilf( ):
    H_trf( )
    global w_til
    
    w_til = np.ones((i, r))
    
    for c in range(i):
        for j in range(r):
            w_til[c, j] = ( (1 - tau_w[c, j]) / (1 + tau_h[c, j]) ** eta ) * H_tr[c, j]**varphi * w[c, j] * s[c]**phi[c] * (1 - s[c]) ** ( (1- eta) /beta )           

    return w_til

#taus()
#w_tilf()

# tenho que mudar o H_tr 



#------------------------------------------ p_ir
    
        
def p_irf( ):
    global p_ir, p_i, w_r
    w_tilf( )
        
    w_r = w_til**theta
    w_r = w_r.sum(axis = 1) 

    
    p_ir = np.ones((i, r))
    
    for c in range(i):
        for j in range(r):
            p_ir[c, j] = ( w_til[c, j] ) ** theta / w_r[c]
            
    #p_i = np.sum(p_ir)

    p_i = np.sum(p_ir, axis =1) 
    return p_ir
 





# p_ir.sum(axis=1)    # this sum get me a vector with ones


#---------------------------------------  W (eq 27)



def Wf():
    global W
    W = np.zeros((i, r))
    
    for c in range(i):
        for j in range(r):
            W[c, j] = ((1 - s[c])**(-1/beta))/(1-tau_w[c, j])*gamma1*eta*(w_til[c, j]**theta)**(1/(theta*(1 - eta)))     #        (eq 27)
    return W


    
    
#--------- Simulated data 


def simul():
    global W_t, p_t
    #np.random.seed(3)
    #W_t = np.random.rand(i, r)   # simulated W - I get this in PNAD
    #W_t = np.array(([0.8, 0.42, 0.33, 0.12], [0.99, 0.22, 0.154, 0.654]))
    W_t = np.array([[0.50324672, 0.60448746, 0.83584016, 0.66215481, 0.01753751,
        0.94396669, 0.16332265, 0.23054438, 0.51921995, 0.14861905,
        0.83690369, 0.21955178, 0.568021  , 0.57508231, 0.95821434,
        0.95061822, 0.53711055, 0.58411075, 0.4733686 , 0.63963475,
        0.35291815, 0.99556786, 0.69881437, 0.24319101, 0.78835878,
        0.48057067, 0.68833221],
       [0.93431306, 0.38258376, 0.5768931 , 0.91603185, 0.76393869,
        0.54304256, 0.92593378, 0.15394458, 0.07568385, 0.95907697,
        0.22851262, 0.38162588, 0.01531181, 0.40220091, 0.21910961,
        0.15673925, 0.58825585, 0.19244215, 0.87762736, 0.97960654,
        0.45459278, 0.09827613, 0.72957432, 0.34350798, 0.32035673,
        0.50468138, 0.86498694],
       [0.83491921, 0.9568414 , 0.09450609, 0.81034522, 0.96203506,
        0.38928345, 0.61409445, 0.62355485, 0.62752237, 0.12238558,
        0.5512092 , 0.08883107, 0.83679289, 0.7809147 , 0.33976656,
        0.68948617, 0.54124482, 0.66866233, 0.27072371, 0.98266622,
        0.07759311, 0.63904284, 0.2908096 , 0.43479598, 0.78789413,
        0.01758243, 0.0475042 ],
       [0.96310345, 0.57416378, 0.78128097, 0.50889084, 0.12865108,
        0.35176546, 0.06053795, 0.85710624, 0.8960948 , 0.52798291,
        0.22599074, 0.40109749, 0.71459461, 0.3937882 , 0.72529027,
        0.96109129, 0.64420979, 0.82141275, 0.27739293, 0.9318184 ,
        0.26012292, 0.41123542, 0.82445302, 0.53498538, 0.55773441,
        0.42497343, 0.20351104],
       [0.74237924, 0.00675925, 0.64120665, 0.28985578, 0.35125841,
        0.2605274 , 0.81702832, 0.82815542, 0.26495507, 0.90930011,
        0.13645264, 0.96290372, 0.75457884, 0.66734733, 0.62514552,
        0.27725492, 0.10847967, 0.1545535 , 0.75287237, 0.1599796 ,
        0.95278012, 0.12221673, 0.10316316, 0.07657817, 0.69071222,
        0.06282492, 0.51122049],
       [0.14656597, 0.79303441, 0.5624022 , 0.75748323, 0.40566595,
        0.69041114, 0.87009316, 0.17911784, 0.40631153, 0.40448791,
        0.78595816, 0.35910723, 0.01777518, 0.29580109, 0.74642429,
        0.2132768 , 0.3542234 , 0.15728754, 0.4283819 , 0.91627477,
        0.56155454, 0.34160953, 0.39620875, 0.3357625 , 0.23026452,
        0.29106353, 0.46010635],
       [0.92334566, 0.99243738, 0.03735226, 0.59921053, 0.74240307,
        0.5541851 , 0.98750199, 0.60820536, 0.07646989, 0.45859006,
        0.56272907, 0.31571832, 0.58965699, 0.9905271 , 0.29855115,
        0.34875232, 0.48225721, 0.01376898, 0.81014567, 0.28527871,
        0.94126153, 0.74055535, 0.56476074, 0.20629593, 0.29168105,
        0.01353893, 0.53651491]])
    
    #np.random.seed(3)
    #p_t = np.random.rand(i, r)
    #p_t = np.array(([0.822, 0.32, 0.132, 0.109], [0.212, 0.453, 0.3524, 0.114]))
    p_t = np.array([[0.99919255, 0.6720661 , 0.49502279, 0.4400015 , 0.73074109,
        0.83766898, 0.91830139, 0.40660004, 0.18261179, 0.87740927,
        0.99052364, 0.00942495, 0.56754712, 0.975728  , 0.6459171 ,
        0.38425396, 0.22921888, 0.11193025, 0.72967646, 0.81181358,
        0.26975122, 0.84279033, 0.22958761, 0.46918531, 0.18233898,
        0.62770674, 0.56980684],
       [0.97399516, 0.86015464, 0.66246011, 0.68145868, 0.92859275,
        0.93049224, 0.0097775 , 0.41905819, 0.04806278, 0.71462034,
        0.63930034, 0.53754712, 0.52356719, 0.36174479, 0.86143754,
        0.97183082, 0.72145417, 0.01119079, 0.58836819, 0.71690915,
        0.27840864, 0.46483152, 0.45757487, 0.24742327, 0.59533269,
        0.81443101, 0.1546315 ],
       [0.41347108, 0.93028463, 0.67546437, 0.96981662, 0.27287312,
        0.37511167, 0.39586791, 0.32816617, 0.74283276, 0.55191704,
        0.20103317, 0.04867992, 0.54001638, 0.52602853, 0.72255346,
        0.04554694, 0.1706061 , 0.89125379, 0.32143733, 0.46442652,
        0.38577427, 0.99356169, 0.78648576, 0.72175255, 0.1795224 ,
        0.16187789, 0.29846316],
       [0.40030937, 0.75850154, 0.11346481, 0.1753601 , 0.56457387,
        0.8350975 , 0.11685587, 0.63489223, 0.0305977 , 0.92986725,
        0.99649077, 0.55824277, 0.92568973, 0.08652124, 0.70689378,
        0.2998514 , 0.60100086, 0.43066695, 0.30832468, 0.99333276,
        0.1746082 , 0.16270836, 0.21600635, 0.72825588, 0.94142974,
        0.25580593, 0.83654374],
       [0.3067927 , 0.18489536, 0.4957363 , 0.27032404, 0.04580653,
        0.75235231, 0.08136591, 0.32485439, 0.85316936, 0.85686673,
        0.23782985, 0.53764433, 0.26694932, 0.07370342, 0.3176906 ,
        0.71868031, 0.22930164, 0.00614834, 0.70105935, 0.93287652,
        0.62443434, 0.38738308, 0.71806411, 0.35568982, 0.61994137,
        0.06404949, 0.60987928],
       [0.82081743, 0.67838446, 0.68112075, 0.40837838, 0.21551035,
        0.08088992, 0.50179434, 0.92391538, 0.97574815, 0.09757623,
        0.62659647, 0.74415645, 0.86428994, 0.38235139, 0.03036978,
        0.25379206, 0.27878632, 0.8403923 , 0.29994465, 0.1690868 ,
        0.61655661, 0.73877125, 0.26046813, 0.71012368, 0.11597852,
        0.05089184, 0.4313506 ],
       [0.54050935, 0.80986032, 0.99241929, 0.17393367, 0.24177069,
        0.15598715, 0.56800796, 0.10922294, 0.11157281, 0.9352289 ,
        0.05012197, 0.89482758, 0.15856708, 0.41995739, 0.67350812,
        0.91817874, 0.95083347, 0.17579743, 0.26536345, 0.19669204,
        0.27922274, 0.75145198, 0.43899074, 0.79049011, 0.94472915,
        0.57248198, 0.11047471]])



#----------------------- Tau's  & w (TPF)

#
    
def taus2():
    global x1, tau_h, tau_w, w
    par()
    #np.random.seed(40)
    
    tau_h = np.random.rand(i, r)
    tau_h[0, :] = 0

    tau_w = np.random.uniform(low=-1, high=1, size=(i,r))
    tau_w[0, : ] = tau_w[0, 0]
    
    w =np.random.uniform(low=0, high=1, size=(i,r))
    w[:, r-1] = 1
    
    x1 = np.array( [tau_w, tau_h, w] )
    
    return x1
    #x0 = x0.reshape(-1, 1)


taus2()

#
    
def taus():
    global x0, tau_h, tau_w, w
    par()
    #np.random.seed(40)
    
    tau_h = np.ones((i, r))*0.2123
    tau_w = np.ones((i, r))*0.5673
    
    w = np.ones((i, r))*0.1345
    
    x0 = np.array([ [tau_w], [tau_h], [w] ])
    x0 = x0.reshape(3, i, r)
    
    return x0
    #x0 = x0.reshape(-1, 1)





#--------------------- OBJECTIVE FUNCTION

 

def obj(tau):
    global D, tau_w, tau_h, w
    #taus()
    
    tau = tau.reshape((3, i, r))
    tau_w = tau[0]
    tau_h = tau[1]
    w = tau[2]
#    
#    print('tau_w = ', tau_w)    
#    print('  ')
    
    sf()
    w_tilf()
    p_irf()

    Hf()
    Wf()
    simul()

#    print('w_til =', w_til)
#    print('H =', H)
#    print('W =', W)
    
    D =  np.sum ( ((W - W_t) / W_t)**2  +  ((p_ir - p_t) / p_t)**2 ) 

    return D


  






#----------------------------- OPTIMIZATION Scipy




taus()
obj(x0)



taus2()
obj(x1)


np.seterr(over='raise')
sol = minimize(obj, x1,  method='Nelder-Mead', options={'maxiter':10e5})

sol 

sol.fun
sol.x 



#--------------------------- OPTIMIZATION Marcos's Algorithm
 

def hsieh(n, t=12):
    global opt, k
    opt = [t]
    k = np.zeros((3, i, r))

    for z in itl.count():
        
        if z < n+1:
            taus2()
            res = obj(x1)
            print(z)
            
            if res < opt[0]:
                opt.remove(opt[0])
                opt.append(res)
                k = x1
        else: 
            break



taus2()
obj(x1)




def calibration(v, t=12):
    
    start = time.time()
    hsieh(v, t)
    end = time.time()
            
    print('\033[1;033m=-'*25)
    print('{:*^50}'.format('Hsieh Model'))
    print('=-'*25)
    print('   ')
    
    print('\033[1;033mElapsed time:', (end - start))
    print('   ')
        

    print(f'tau_w is given by: \n {k[0]}')
    print('   ')

    print(f'tau_h is given by: \n {k[1]}')
    print('   ')

    print(f'w is given by: \n {k[2]}')
    print('   ')

    print(f'The minimun value to D is: {opt}')
    print('   ') 
    
    print('{:*^50}'.format('End of calibration'))


import time

calibration(100000, 355)



#-------------------- Constraints
    


def c1(tau):
    tau = tau.reshape((3, i, r))
    return tau_h[0, :] - 0      
        


def c2(tau):    
    tau = tau.reshape((3, i, r))
    return tau_w[0, : ] - tau_w[0, 0 ]



def c3(tau):
    tau = tau.reshape((3, i, r))
    return w[:, r-1] - 1

        
    


con1 = {'type': 'eq', 'fun':c1}
con2 = {'type': 'eq', 'fun':c2}
con3 = {'type': 'eq', 'fun':c3}


cons = [con2]




 
taus2()
 
sol = minimize(obj, x1, method='SLSQP', options={'maxiter':10e8}, constraints=cons)
sol
 


obj(x0)
sol
















